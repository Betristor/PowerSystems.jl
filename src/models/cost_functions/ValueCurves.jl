"Type that represents an abstract cost curve without units on the cost"
abstract type ValueCurve{T <: FunctionData} end

# JSON SERIALIZATION
IS.serialize(val::ValueCurve) = IS.serialize_struct(val)
IS.deserialize(T::Type{<:ValueCurve}, val::Dict) = IS.deserialize_struct(T, val)

"Get the underlying `FunctionData` representation of this `ValueCurve`"
get_function_data(curve::ValueCurve) = curve.function_data

"""
An input-output curve, directly relating the production quantity to the cost: `y = f(x)`.
Can be used, for instance, in the representation of a [`CostCurve`](@ref) where `x` is MW
and `y` is currency/hr, or in the representation of a [`FuelCurve`](@ref) where `x` is MW
and `y` is fuel/hr.
"""
@kwdef struct InputOutputCurve{
    T <: Union{QuadraticFunctionData, LinearFunctionData, PiecewiseLinearData},
} <: ValueCurve{T}
    "The underlying `FunctionData` representation of this `ValueCurve`"
    function_data::T
end

"""
An incremental (or 'marginal') curve, relating the production quantity to the derivative of
cost: `y = f'(x)`. Can be used, for instance, in the representation of a [`CostCurve`](@ref)
where `x` is MW and `y` is currency/MWh, or in the representation of a [`FuelCurve`](@ref)
where `x` is MW and `y` is fuel/MWh.
"""
@kwdef struct IncrementalCurve{T <: Union{LinearFunctionData, PiecewiseStepData}} <:
              ValueCurve{T}
    "The underlying `FunctionData` representation of this `ValueCurve`"
    function_data::T
    "The value of f(x) at the least x for which the function is defined, or the origin for functions with no left endpoint, used for conversion to `InputOutputCurve`"
    initial_input::Float64
end

"""
An average rate curve, relating the production quantity to the average cost rate from the
origin: `y = f(x)/x`. Can be used, for instance, in the representation of a
[`CostCurve`](@ref) where `x` is MW and `y` is currency/MWh, or in the representation of a
[`FuelCurve`](@ref) where `x` is MW and `y` is fuel/MWh. Typically calculated by dividing
absolute values of cost rate or fuel input rate by absolute values of electric power.
"""
@kwdef struct AverageRateCurve{T <: Union{LinearFunctionData, PiecewiseStepData}} <:
              ValueCurve{T}
    "The underlying `FunctionData` representation of this `ValueCurve`, in the case of `AverageRateCurve{LinearFunctionData}` representing only the oblique asymptote"
    function_data::T
    "The value of f(x) at the least x for which the function is defined, or the origin for functions with no left endpoint, used for conversion to `InputOutputCurve`"
    initial_input::Float64
end

"Get the `initial_input` field of this `ValueCurve` (not defined for `InputOutputCurve`)"
get_initial_input(curve::Union{IncrementalCurve, AverageRateCurve}) = curve.initial_input

# BASE METHODS
Base.:(==)(a::T, b::T) where {T <: ValueCurve} = IS.double_equals_from_fields(a, b)

Base.isequal(a::T, b::T) where {T <: ValueCurve} = IS.isequal_from_fields(a, b)

Base.hash(a::ValueCurve) = IS.hash_from_fields(a)

"Get an `InputOutputCurve` representing `f(x) = 0`"
Base.zero(::Union{InputOutputCurve, Type{InputOutputCurve}}) =
    InputOutputCurve(zero(FunctionData))

"Get an `IncrementalCurve` representing `f'(x) = 0` with zero `initial_input`"
Base.zero(::Union{IncrementalCurve, Type{IncrementalCurve}}) =
    IncrementalCurve(zero(FunctionData), 0.0)

"Get an `AverageRateCurve` representing `f(x)/x = 0` with zero `initial_input`"
Base.zero(::Union{AverageRateCurve, Type{AverageRateCurve}}) =
    AverageRateCurve(zero(FunctionData), 0.0)

"Get a `ValueCurve` representing zero variable cost"
Base.zero(::Union{ValueCurve, Type{ValueCurve}}) =
    Base.zero(InputOutputCurve)

# CONVERSIONS: InputOutputCurve{LinearFunctionData} to InputOutputCurve{QuadraticFunctionData}
InputOutputCurve{QuadraticFunctionData}(data::InputOutputCurve{LinearFunctionData}) =
    InputOutputCurve{QuadraticFunctionData}(get_function_data(data))

Base.convert(
    ::Type{InputOutputCurve{QuadraticFunctionData}},
    data::InputOutputCurve{LinearFunctionData},
) = InputOutputCurve{QuadraticFunctionData}(data)

# CONVERSIONS: InputOutputCurve to X
function IncrementalCurve(data::InputOutputCurve{QuadraticFunctionData})
    fd = get_function_data(data)
    q, p, c = get_quadratic_term(fd), get_proportional_term(fd), get_constant_term(fd)
    return IncrementalCurve(LinearFunctionData(2q, p), c)
end

function AverageRateCurve(data::InputOutputCurve{QuadraticFunctionData})
    fd = get_function_data(data)
    q, p, c = get_quadratic_term(fd), get_proportional_term(fd), get_constant_term(fd)
    return AverageRateCurve(LinearFunctionData(q, p), c)
end

IncrementalCurve(data::InputOutputCurve{LinearFunctionData}) =
    IncrementalCurve(InputOutputCurve{QuadraticFunctionData}(data))

AverageRateCurve(data::InputOutputCurve{LinearFunctionData}) =
    AverageRateCurve(InputOutputCurve{QuadraticFunctionData}(data))

function IncrementalCurve(data::InputOutputCurve{PiecewiseLinearData})
    fd = get_function_data(data)
    return IncrementalCurve(
        PiecewiseStepData(get_x_coords(fd), get_slopes(fd)),
        first(get_points(fd)).y,
    )
end

function AverageRateCurve(data::InputOutputCurve{PiecewiseLinearData})
    fd = get_function_data(data)
    points = get_points(fd)
    slopes_from_origin = [p.y / p.x for p in points[2:end]]
    return AverageRateCurve(
        PiecewiseStepData(get_x_coords(fd), slopes_from_origin),
        first(points).y,
    )
end

# CONVERSIONS: IncrementalCurve to X
function InputOutputCurve(data::IncrementalCurve{LinearFunctionData})
    fd = get_function_data(data)
    p = get_proportional_term(fd)
    (p == 0) && return InputOutputCurve(
        LinearFunctionData(get_constant_term(fd), get_initial_input(data)),
    )
    return InputOutputCurve(
        QuadraticFunctionData(p / 2, get_constant_term(fd), get_initial_input(data)),
    )
end

function InputOutputCurve(data::IncrementalCurve{PiecewiseStepData})
    fd = get_function_data(data)
    c = get_initial_input(data)
    points = running_sum(fd)
    return InputOutputCurve(PiecewiseLinearData([(p.x, p.y + c) for p in points]))
end

AverageRateCurve(data::IncrementalCurve) = AverageRateCurve(InputOutputCurve(data))

# CONVERSIONS: AverageRateCurve to X
function InputOutputCurve(data::AverageRateCurve{LinearFunctionData})
    fd = get_function_data(data)
    p = get_proportional_term(fd)
    (p == 0) && return InputOutputCurve(
        LinearFunctionData(get_constant_term(fd), get_initial_input(data)),
    )
    return InputOutputCurve(
        QuadraticFunctionData(p, get_constant_term(fd), get_initial_input(data)),
    )
end

function InputOutputCurve(data::AverageRateCurve{PiecewiseStepData})
    fd = get_function_data(data)
    c = get_initial_input(data)
    xs = get_x_coords(fd)
    ys = xs[2:end] .* get_y_coords(fd)
    return InputOutputCurve(PiecewiseLinearData(collect(zip(xs, vcat(c, ys)))))
end

IncrementalCurve(data::AverageRateCurve) = IncrementalCurve(InputOutputCurve(data))

# CALCULATIONS
is_convex(curve::InputOutputCurve) = is_convex(get_function_data(curve))
"Calculate the convexity of the underlying data"
is_convex(curve::ValueCurve) = is_convex(InputOutputCurve(curve))
